#! /usr/bin/env bash
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/stderr 2>&1 && pwd )"
set -euo pipefail

export BLDR_X86="${BLDR_X86:-$(tailscale ip --6 slynux)}";
export BLDR_A64="${BLDR_A64:-"colemickens@aarch64.nixos.community"}";

function _h1() { printf "\n=======================================================\n${1}\n=======================================================\n" >/dev/stderr; }
function _h2() { printf "\n-- ${1} \n" >/dev/stderr; }

function nixup() { "${0}" "${@}"; }

function nixbuild() { "${DIR}/misc/nixbuild.sh" "${@}"; }
function activate() { "${DIR}/misc/activate.sh" "${@}"; }

# TODO: what we want:
# FLAKE_LOCK=flake.dev.lock nix run .#apps.${arch}.deploy-${host}
# -> that's a script that just executes ./misc/nixbuild.sh
# -> and then runs ./misc/activate.sh with the right stuff?

srcdirs=(
  "${HOME}/code/nixpkgs/master"
  "${HOME}/code/nixpkgs/cmpkgs"
  "${HOME}/code/nixpkgs/cmpkgs-cross-riscv64"
  "${HOME}/code/nixpkgs/cmpkgs-cross-armv6l"
  "${HOME}/code/home-manager/cmhm"
  "${HOME}/code/tow-boot/development"
  "${HOME}/code/tow-boot/rpi"
  "${HOME}/code/tow-boot/radxa-zero"
  "${HOME}/code/tow-boot/visionfive"
  "${HOME}/code/tow-boot/lteusb8916"
  "${HOME}/code/nixpkgs-wayland"
  "${HOME}/code/visionfive-nix"
  "${HOME}/code/flake-firefox-nightly"
  "${HOME}/code/mobile-nixos/master"
  "${HOME}/code/mobile-nixos/blueline-mainline-only--2022-08"
  "${HOME}/code/mobile-nixos/openstick"
  "${HOME}/code/nix-coreboot"
)
resets=(
  "${HOME}/code/tow-boot/development"
  "${HOME}/code/nixpkgs/master"
)

cmd="${1:-"z"}"; shift || true

case "${cmd}" in

  "pkgup")   _h1 "pkgup";    "${DIR}/pkgs/update.sh" "${@}"; ;;
  "rpiup")   _h1 "rpiup";    "${DIR}/misc/rpi/rpipkgs.sh"; ;;
  "lockup")  _h1 "lockup";   (set -x; cd "${DIR}"; nix "${nixargs[@]}" flake lock --recreate-lock-file --commit-lock-file); ;;
  "shellup") _h1 "shellup";  nixbuild "auto" "cachix:colemickens" ".#cache-dev"; ;;
  "inputup") _h1 "inputup";
    for s in "${srcdirs[@]}"; do
      _h2 "inputup - ${s}"
      test -d "${s}" || return;
      set -x
      git -C "${s}" rebase --abort || true; git -C "${s}" pull --rebase;  git -C "${s}" push origin HEAD -f;
      set +x
    done;
  ;;
  "up") _h1 "upup";
    unset FLAKE_LOCK || true
    true \
    && nixup inputup \
    && nixup rpiup \
    && nixup lockup \
    && nixup pkgup \
    && nixup shellup 
  ;;
  "cache-all") _h1 "cache-all";
    ./nixup build ".#cache-all"
  ;;
  "upz") _h1 "upz";
    unset FLAKE_LOCK || true
    nixup up
    date
  ;;
  "upzz") _h1 "upzz";
    unset FLAKE_LOCK || true
    nixup upz
    # nixup cache-all
    nixup deploy slynux
    nixup deploy jeffhyper
    nixup deploy raisin
    nixup deploy openstick
    nixup deploy carbon || true
    nixup deploy xeep
    date
  ;;

  "build")
    while [[ -f "${FLAKE_LOCK:-"flake.lock"}-lock" ]]; do sleep 0.1; printf "." >/dev/stderr; done; echo "using FLAKE_LOCK: ${FLAKE_LOCK:-"flake.lock"}">&2
    nixbuild "auto" "cachix:colemickens" "${@}";
  ;;
  "_build")
    while [[ -f "${FLAKE_LOCK:-"flake.lock"}-lock" ]]; do sleep 0.1; printf "." >/dev/stderr; done; echo "using FLAKE_LOCK: ${FLAKE_LOCK:-"flake.lock"}">&2
    nixbuild "${@}"
  ;;
  "deploy")
    set -o errtrace
    host="${1}"; shift || true
    export NIXUP_LOGDIR="${NIXUP_LOGDIR:-"$(mktemp -d --tmpdir "nixup.XXXXXXXXXXX")"}/${host}";  mkdir -p "${NIXUP_LOGDIR}"
    echo "NIXUP_LOGDIR = ${NIXUP_LOGDIR}"
    # FLAKE_LOCK-lock:
    while [[ -f "${FLAKE_LOCK:-"flake.lock"}-lock" ]]; do sleep 0.1; printf "." >/dev/stderr; done; echo "using FLAKE_LOCK: ${FLAKE_LOCK:-"flake.lock"}">&2
    if [[ "${host}" == "$(hostname)" ]]; then export NIXUP_ACTION="switch"; fi
    if [[ "${host}" == "raisin" ]]; then export NIXUP_ACTION="switch"; fi
    if [[ "${host}" == "xeep" ]]; then export NIXUP_ACTION="switch"; fi
    touch "${NIXUP_LOGDIR}/lock"
    trap 'rm "${NIXUP_LOGDIR}/lock"' EXIT

    trap 'echo "-fail" >> ${NIXUP_LOGDIR}/status' ERR

    stdout="${NIXUP_LOGDIR}/stdout"
    stderr="${NIXUP_LOGDIR}/stderr"

    printf "nixbuild" > "${NIXUP_LOGDIR}/status"
    nixup _build "auto" "cachix:colemickens" ".#toplevels.${host}" "${@}" \
      > >(tee -a ${stdout}) 2> >(tee -a ${stderr} >&2)
    outres="$(cat "${stdout}")"

    printf "activate" > "${NIXUP_LOGDIR}/status"
    activate "${NIXUP_ACTION:-"switch"}" "${outres}" "${host}" \
      > >(tee -a ${stdout}) 2> >(tee -a ${stderr} >&2)
    outres="$(cat "${stdout}")"
  ;;
  "rdeploy") export NIXUP_ACTION="reboot"; nixup deploy "${@}"; ;;
  
  "pi-on")
    curl -s -X POST -H "Authorization: Bearer $(cat /run/secrets/home-assistant-bearer-token)" -H "Content-Type: application/json" -d "{\"entity_id\": \"switch.${1}\"}" \
        https://home.x.cleo.cat/api/services/switch/turn_on >/dev/null
  ;;
  "pi-off")
    curl -s -X POST -H "Authorization: Bearer $(cat /run/secrets/home-assistant-bearer-token)" -H "Content-Type: application/json" -d "{\"entity_id\": \"switch.${1}\"}" \
        https://home.x.cleo.cat/api/services/switch/turn_off >/dev/null
  ;;
  "pitest")
    
    set -x
    while true;
    do
      set +eo pipefail
      netboots1_out="$(nixup build .#bundles.x86_64-linux.netboots)"
      netboots2_out="$(nixup build .#bundles.aarch64-linux.netboots)"
      if ssh "cole@$(tailscale ip --4 xeep)" "nix-store -r ${netboots1_out} --option narinfo-cache-negative-ttl 0" &&
        ssh "cole@$(tailscale ip --4 xeep)" "nix-store -r ${netboots2_out} --option narinfo-cache-negative-ttl 0";
      then
        echo "yes"
        break
      else
        echo "no"
      fi
      
      echo "riscv build failed, probably nix bug, will retry in 10 seconds"
      sleep 10
    done
    set -eo pipefail
    
    export BLDR_X86="$(tailscale ip --4 xeep)"
    nixup deploy xeep
    nixup pireboot
  ;;
  "pireboot")
    pis=(
      "wp6_sw106_relay" # rpi-powerstrip
      "wp6_sw103_relay" # visionfive
    )
    parallel -j$(nproc) --halt 1 --verbose --tag "${DIR}/nixup pi-off" ::: "${pis[@]}"
    sleep 1
    parallel -j$(nproc) --halt 1 --verbose --tag "${DIR}/nixup pi-on" ::: "${pis[@]}"
  ;;

  # # FLAKE_LOCK related
  # "watchlock")
  #   # `watchlock` is a very "scenario"-specific set of
  #   # options, but it's meant to update a custom lockfile
  #   # for use in shells with FLAKE_LOCK set.
  #   # ideas:
  #   #  - it would be neat to have this wrapped into a lil tool
  #   #  - it could do hot re-eval in the future, etc
    
  #   set -x
  #   echo "FLAKE_LOCK=${FLAKE_LOCK}"
  #   (set -x; cd "${DIR}"; nix "${nixargs[@]}" flake lock --recreate-lock-file)
  #   watchexec \
  #     --clear \
  #     --restart \
  #     --ignore '*.watchman*' \
  #     --project-origin $HOME/code/nixcfg \
  #     --workdir $HOME/code/nixcfg \
  #     -w $HOME/code/nixpkgs \
  #     -w $HOME/code/mobile-nixos \
  #     -w $HOME/code/home-manager/cmhm \
  #     -w $HOME/code/vision-five \
  #     -w $HOME/code/tow-boot/ \
  #     -- \
  #     $HOME/code/nixcfg/nixup watchlockup
  # ;;
  # "watchlockup")
  #   # this is what `watchlock` calls internally
  #   # but it can also be used instead of the watch
  #   # for a one-time update of FLAKE_LOCK
  #   touch "${FLAKE_LOCK}-lock"
  #   echo ":: start :: ${FLAKE_LOCK}-lock" >/dev/stderr
  #   nix flake lock \
  #     --recreate-lock-file \
  #     --verbose \
  #     --override-input nixpkgs $HOME/code/nixpkgs/cmpkgs \
  #     --override-input rpipkgs $HOME/code/nixpkgs/cmpkgs-rpipkgs \
  #     --override-input cross-armv6l  $HOME/code/nixpkgs/cmpkgs-cross-armv6l \
  #     --override-input cross-riscv64  $HOME/code/nixpkgs/cmpkgs-cross-riscv64 \
  #     --override-input home-manager $HOME/code/home-manager/cmhm \
  #     --override-input visionfive-nix  $HOME/code/visionfive-nix \
  #     --override-input mobile-nixos  $HOME/code/mobile-nixos \
  #     --override-input tow-boot-rpi $HOME/code/tow-boot/rpi \
  #     --override-input tow-boot-radxa-zero $HOME/code/tow-boot/radxa-zero
  #   echo ":: done :: ${FLAKE_LOCK}-lock" >/dev/stderr
  #   rm "${FLAKE_LOCK}-lock"
  # ;;
    
  *) printf "!!! unknown command\n" >/dev/stderr; exit -1; ;;
esac
